0)   Сигнатура функции 
- это заголовок, как правило содержащий:

1. имя функции

2. число, тип и порядок следоваения передаваемых в неё параметров


Например:

a) double f(char* par1, int par2);
показывает, что ф-я получает один параметр типа char* и один параметр типа int (при этом функция возвращает тип double)

b) double f(char* par1, int par2, float par3);
одновременно пример и для различных сигнатур, и для перегрузки ф-ий (см. ниже).

c) int f(char* par1, int par2);
сигнатура такая же, как у (a) ф-ии => они не различимы


1)   Полиморфизм
 - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. 

"Один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор. 

Полиморфизм может применяться также и к функциям. Примером этого утверждения является так называемая "перегрузка функций".


2) Перегрузка функций
- определение нескольких функций с одинаковым именем, но различными параметрами. Наборы параметров перегруженных функций могут отличаться порядком следования, количеством, типом. Таким образом перегрузка функций нужна для того, чтобы избежать дублирования имён функций, выполняющих сходные действия, но с различной программной логикой.

Пример выше.

3) Аргументы по умолчанию
 — это параметры функции, которые имеют определенное значение по умолчанию. Если пользователь не передает в функцию значение для параметра по умолчанию, то будет использоваться значение по умолчанию. Если же пользователь передает значение, то это значение будет использоваться вместо значения по умолчанию.

Пример:
void printValues(int a=10, int b=11, int c=12)
{
    std::cout << "Values: " << a << " " << b << " " << c << '\n';
}

При следующих вызовах функции:

printValues(3, 4, 5);
printValues(3, 4);
printValues(3);
printValues();

Результат следующий:

Values: 3 4 5
Values: 3 4 12
Values: 3 11 12
Values: 10 11 12


4) Шаблон функции
— это инструкции, согласно которым создаются локальные версии шаблонированной функции для определенного набора параметров и типов данных.

Функции-шаблоны создаются с использованием ключевого слова template (шаблон). Шаблон исполь­зуется для создания каркаса функции, оставляя компилятору реализацию подробностей. Общая форма функции-шаблона имеет следующий вид:

template <class птип> возвращаемый_тип имя_функции(список параметров)
{
// тело функции
}

Здесь птип является параметром-типом, «держателем места» (placeholder) для имени типа дан­ных, которое используется функцией. Этот параметр-тип может быть использован в определении функции. Однако это только «держатель места», который будет автоматически заменен компи­лятором на фактический тип данных во время создания конкретной версии функции.


5) Специализация шаблонов
Специализация используется, если для какого-то конкретного типа данных (скажем int) нужно использовать иную реализацию функции.

Есть шаблон для обобщенного типа данных:

template <typename T>
void Swap(T &, T &);

Специализация для данного шаблона, например:

template <>
void Swap<int>(int &, int &);

(Но того же можно добиться определив обычную функцию
void Swap(int &, int &);)


6) Ссылка
 — это тип переменной в C++, который работает как псевдоним другого объекта или значения.

C++ поддерживает три типа ссылок:

a) ссылки на неконстантные значения 

b) ссылки на константные значения 

c) в C++11 добавлены ссылки на r-value

Ссылка (на неконстантное значение) объявляется с использованием амперсанда (&) между типом и именем ссылки:

int value = 7; // обычная переменная
int &ref = value; // ссылка на переменную value

Правила работы со ссылками:

a) Ссылки должны быть инициализированы при создании

b) Ссылки нулевыми быть не могут

c) Ссылки не могут быть переприсвоены


7) inline (Встроенные функции)

Использовать ключевое слово inline можно, просто поставив его перед именем функции. Затем, использовать её как обычную функцию.

Основная идея в том, чтобы ускорить программу ценой занимаемого места. После определения встроенной функции с помощью ключевого слова inline, всякий раз когда она будет вызываться, компилятор будет заменять вызов функции фактическим кодом из функции.

Встраиваемые функции могут влиять на некоторые характеристики программы.

Скорость:

a) быстрее - внедрение кода функции в код программы поможет избежать использования лишних инструкций (связанных с вызовом функции и возвратом из нее)

b) медленнее - слишком частое использование встраиваемых функций, к тому же больших, приведет к разрастанию кода (помимо этого, компилятор иногда вынужден использовать дополнительные временные переменные, чтобы сохранить семантику), что может привести в пробуксовке, т.е. в процессе работы программы операционной системе постоянно потребуется производить подкачку новых страниц

Размер исполняемого файла:

a) увеличить - как уже упоминалось, слишком частое использование встраиваемых функций, к тому же больших, приведет к разрастанию кода и соответственно увеличению размера исполняемого файла

b) уменьшить - благодаря оптимизирующему компилятору размер исполняемого файла может и уменьшиться при использовании очень маленьких встраиваемых функций, так как компилятору при этом не нужно будет создавать "лишние" инструкции для вызова функции и выхода из нее, помещению аргументов в стек и обратно. Так же во время внедрения большой встраиваемой функции в код программы оптимизирующий компилятор может удалить избыточный код, что опять же может уменьшить размер файла.


8) auto и decltype

В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения. Это может использоваться при объявлении переменных в различных областях видимости, как, например, пространство имен, блоки, инициализация в цикле и т.п. 
auto i = 42;        // i - int
auto l = 42LL;      // l - long long
auto p = new foo(); // p - foo*

decltype позволяет статически определить тип по типу другой переменной.

int x = 5;
double y = 5.1;

decltype(x) foo;    // int
decltype(y) bar;    // double

decltype(x+y) baz;  // double