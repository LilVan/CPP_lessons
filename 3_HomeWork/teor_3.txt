0. lvalue и rvalue ссылки
lvalue (locator value) - объект, который занимает идентифицируемое место в памяти (например, имеет адрес).

rvalue - любое выражение, которое не является lvalue. Таким образом из определения lvalue следует, что rvalue — это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти.

Формально C99 стандарт определяет изменяемые lvalue как:
[...] lvalue, тип которого не является массивом, не является неполным, не имеет спецификатор const, не является структурой или объединением, содержащими поля (также включая поля, рекурсивно вложенные в содержащиеся агрегаты и объединения) со спецификатором const.

Все lvalue, которые не являются массивом, функцией и не имеют неполный тип, могут быть преобразованы в rvalue.
Преобразовать же rvalue в lvalue нельзя! 

Ссылки на Rvalue:
Rvalue ссылка ведет себя точно так же, как и lvalue ссылка, за исключением того, что она может быть связана с временным объектом, тогда как lvalue связать с временным (не константным) объектом нельзя.

Двойной асперсанд — это ссылка на rvalue. Он означает как раз то, что и обещает — даёт ссылку на rvalue. Мы можем «стащить» внутренности rvalue.


1. Виды конструкторов
Constructors may be declared as inline, explicit, friend or constexpr.

Ключевое слово explicit запрещает автоматическое создание конвертирующего конструктора. 

Вот так можно запретить создание автоматичекого конвертирующего конструктора:

class FruitBasket {
  public:      explicit FruitBasket(int);
}

// ...

FruitBasket fb = 5;              // Не прокатит!
FruitBasket fb = FruitBasket(5); // Прокатит! Сработает копирующий конструктор, который тоже создается автоматически 

// ответ на этот вопрос довольно хорошо был описан в manual по Visual Studio для C++
1.0 Copy constructor

A copy constructor initializes an object by copying the member values from an object of the same type.

If your class members are all simple types such as scalar values, the compiler-generated copy constructor is sufficient and you do not need to define your own. If your class requires more complex initialization, then you need to implement a custom copy constructor
// На самом деле 

1.1 Move constructor

A move constructor is a special member function that moves ownership of an existing object's data to a new variable without copying the original data. It takes an rvalue reference as its first parameter, and any additional parameters must have default values. 

Move constructors can significantly increase your program's efficiency when passing around large objects. A move constructor takes an rvalue reference as its first parameter. Any other parameters must have default values.

Box(Box&& other);

1.2 Default constructors

Default constructors typically have no parameters, but they can have parameters with default value.

Default constructors are one of the special member functions. If no constructors are declared in a class, the compiler provides an implicit inline default constructor.


2.0 const в методах класса

Константный метод – это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект).

Чтобы сделать метод константным, нужно просто добавить ключевое слово const к прототипу функции после списка параметров, но перед телом функции


3.0 переопределение операторов в с++

Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). 

Бинарный оператор
Vektor operator+(Vektor const & a, Vektor const & b)
{
    ...
}

Унарный оператор
Vektor & operator++(Vektor const & b)
{
    ...
}

При перегрузке операторов ">>" и "<<", для ввода и вывода через потоки нужно подключить заголовочный файл iostream.

#include <iostream>
...
std::istream & operator >>(std::istream & is, Vektor & n)
{
    ...
}
std::ostream & operator <<(std::ostream & os, Vektor const & n)
{
    ...
}

Переопределение префиксных и постфиксных операторов:

Vektor & operator --(Vektor & n);//Префиксный
Vektor operator --(Vektor & n, int);//Постфиксный
Фактически параметра size_t size у операции нет — он фиктивен. Это хак для того чтобы внести различия в сигнатуры

Переопределение операторов внутри класса:

class Vektor
{
    ...
    Vektor * operator ->();
    char operator [](size_t i) const;
    char & operator [](size_t i);
    ...
};
При переопределении "->" необходимо вернуть именно указатель на объект.

Оператор "[]" переопределен как константный и не константный. Во втором случае мы возвращаем ссылку на объект, а не сам объект. Это может быть полезно при определении массивов.

Для перегрузки оператора "=" есть специальная идиома, которая облегчает присваивание сложных объектов.
Рассмотрим следующий код:

class Vektor
{
    size_t size_;
    char * digits_;

    Vektor(Vektor const & num)
    {
      ...
    }
    
    void swap(Vektor & b)
    {
        std::swap(size_, b.size_);
        std::swap(digits_, b.digits_);
    }
    Vektor & operator = (Vektor const & num)
    {
        if(this != &n)
        {
            Vektor(num).swap(*this);
        }
        return *this;
    } 
    ...
};

Ограничения в перегрузке операторов
Во-первых, почти любой существующий оператор в C++ может быть перегружен. Исключениями являются:

  тернарный оператор (?:);

  оператор sizeof;

  оператор разрешения области видимости (::);

  оператор выбора члена (.);

  указатель как оператор выбора члена (.*).

Во-вторых, вы можете перегружать только существующие операторы. Вы не можете создавать новые или переименовывать существующие. Например, вы не можете создать оператор ** для выполнения операции возведения в степень.

В-третьих, по крайней мере один из операндов перегруженного оператора должен быть пользовательского типа данных. Это означает, что вы не можете перегрузить operator+ для выполнения операции сложения значения int и значения double. Однако вы можете перегрузить operator+ для выполнения операции сложения значения int и объекта Mystring.

В-четвертых, изначальное количество операндов, поддерживаемых оператором, изменить невозможно. Т.е. с бинарным оператором используются только два операнда, с унарным – только один, с тернарным – только три.

Наконец, все операторы сохраняют свой приоритет и ассоциативность по умолчанию (независимо от того, для чего они используются), и это не может быть изменено.

4.0 friend

Дружественная функция — это функция, которая не является членом класса, но имеет доступ к членам класса, объявленным в полях private или protected.

Дружественная функция может располагаться в любом поле класса – private, public или protected. Она при любых обстоятельствах будет иметь доступ к private-элементам класса и, даже если она сама находится в поле private , к ней можно будет обратиться вне класса, не используя специальных методов.

Когда мы определяем дружественную функцию, элементы класса необходимо явно передавать в нее в виде параметров функции. Так как она не является компонентом класса, она не получает указатель this.

В виде параметра, в дружественную функцию так же надо передать указатель или ссылку на объект класса. Иначе она не увидит  данные какого класса ей принять и обработать.

Функция может использоваться, как дружественная к нескольким классам.
Вызываются дружественные функции, как обычные функции. Т.е не используется такой способ — Объект_класса.функция(). После внесения  всех необходимых параметров в нее при вызове, она сама увидит с элементами какого класса и объекта надо работать.


5. Чем отличается new от malloc?

1. new бросает эксепшен в случае неудачи, malloc возвращает 0.

2. new вызывает конструктор класса и выделяет память либо просто вызывает конструктор (в случае placement new), malloc только выделяет память.

3. new нужен для работы с объектами, malloc для работы непосредственно с памятью.

Ключевое слово new также более безопасно для типов, тогда как malloc вообще не безопасно для типов
