0. Static

1) При объявлении члена класса (функции или переменной) ключевое слово static означает, что этот член класса является статическим. 
К статическим членам класса разрешен доступ вида: T::member. 

Статические фуннкции-члены класса не имеют неявного формального параметра this, не могут быть виртуальными или иметь модификатор const. Статические переменные не являются частью объектов данного класса, т.е. являются "общими" для всех объектов данного класса.

  class Object {
    static void foo();
    static int i;
  };

  int Object::i = 0;

  void Object::foo() { }

2) При объявлении локальных переменных функции ключевое слово static означает, что переменная имеет статический класс памяти (static storage duration), т.е. существует в течение всего времени выполнения программы, в отличие от переменных с локальным классом памяти (automatic storage duration).

  void foo() {
    static int i = 0;
  }

3) При объявлении переменных или функций на глобальном уровне (точнее, namespace scope), ключевое слово static означает, что переменная или функция имеет внутреннее связывание (internal linkage), т.е. к ним нет доступа из других единиц трансляции (translation units).

  static int i = 0;
  static void foo() { }


1. Наследование


Наследование — это механизм создания нового класса на основе уже существующего. При этом к существующему классу могут быть добавлены новые элементы (данные и функции), либо существующие функции могут быть изменены. Основное назначение механизма наследования — повторное использование кодов, так как большинство используемых типов данных являются вариантами друг друга, и писать для каждого свой класс нецелесообразно.

Для порождения нового класса на основе существующего используется следующая общая форма

сlass Имя : МодификаторДоступа  ИмяБазовогоКласса
{ объявление_членов;};

При объявлении порождаемого класса МодификаторДоступа может принимать значения public, private, protected либо отсутствовать, по умолчанию используется значение private. В любом случае порожденный класс наследует все члены базового класса, но доступ имеет не ко всем. Ему доступны общие (public) члены базового класса и недоступны частные (private).

Для того, чтобы порожденный класс имел доступ к некоторым скрытым членам базового класса, в базовом классе их необходимо объявить со спецификацией доступа защищенные (protected).

Члены класса с доступом protected видимы в пределах класса и в любом классе, порожденном из этого класса.

Производный класс имеет доступ ко всем элементам и методам базового класса, а базовый класс может использовать только свои собственные элементы и методы.

В производном классе необходимо явно определять свои конструкторы, деструкторы и перегруженные операторы присваивания из-за того, что они не наследуются от базового класса. Но их можно вызвать явным образом при определении конструктора, деструктора или перегрузки оператора присваивания производного класса, например таким образом (для конструктора): Конструктор_Производного_Класса (/*параметры*/)  :  Конструктор_Базового_Класса ( /*параметры*/) { } .


2. public Наследование

Используя public-наследование мы передаем потомкам всё, что есть в основном классе, в таком виде, как и записано в основном классе. Получаем клон основного класса. Разница в том, что элементы основного класса к элементам своего клона отношения не имеют.

сlass A
{
private: int x;
public: int y;
protected: int z;
};

сlass B как потомок A
{
private: int x
public: int y;
protected: int z;
};

сlass C как потомок B
{
private: int x
public: int y;
protected: int z;

 Модификатором доступа прямой контакт из наследника к private-части закрыт.


3. Особенность ссылок и указателей на базовый класс при public наследовании

3.1 Указатели
    В С++ указатель на базовый класс может указывать на объект производного класса, полученного из этого базового класса. 

    Используя указатель , можно получить доступ ко всем членам производного класса, которые наследованы от базового. Однако специфические члены производного класса не могут быть получены с использованием указателя  (по крайней мере до тех пор, пока не будет осуществлено приведение типов). Это является след­ствием того, что указатель «знает» только о членах базового типа и не знает ничего о специфи­ческих членах производных типов.

    Указатель, имею­щий тип указателя на производный класс, не может использоваться для доступа к объектам базо­вого типа.

    Инкремент и декремент указателя выполняются по отношению к его базовому типу. Таким образом, если указатель на базовый тип указывает на объект произ­водного класса, инкремент или декремент его не даст указатель на следующий объект производ­ного класса. Поэтому нельзя использовать операции инкремента и декремента указателей, когда они указывают на объект производного класса.

3.2 Ссылки
    Ссылки на базовый класс могут быть использованы для ссылок на объект производного типа. Такая техника наиболее употребительна при работе с функциями. Если параметр является ссыл­кой на базовый класс, то он может принимать значение ссылки как на объект базового класса, так и на объекты производных типов.


4.Виртуальные методы

Виртуальные функции — специальный вид функций-членов класса. Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.

Для объявления виртуальной функции используется ключевое слово virtual. Функция-член класса может быть объявлена как виртуальная, если
класс, содержащий виртуальную функцию, базовый в иерархии порождения;
реализация функции зависит от класса и будет различной в каждом порожденном классе.

Виртуальная функция — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс. 